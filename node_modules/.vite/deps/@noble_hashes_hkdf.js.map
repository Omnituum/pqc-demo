{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/hkdf.ts"],
  "sourcesContent": ["/**\n * HKDF (RFC 5869): extract + expand in one step.\n * See https://soatok.blog/2021/11/17/understanding-hkdf/.\n * @module\n */\nimport { hmac } from './hmac.ts';\nimport { ahash, anumber, type CHash, clean, type Input, toBytes } from './utils.ts';\n\n/**\n * HKDF-extract from spec. Less important part. `HKDF-Extract(IKM, salt) -> PRK`\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n */\nexport function extract(hash: CHash, ikm: Input, salt?: Input): Uint8Array {\n  ahash(hash);\n  // NOTE: some libraries treat zero-length array as 'not provided';\n  // we don't, since we have undefined as 'not provided'\n  // https://github.com/RustCrypto/KDFs/issues/15\n  if (salt === undefined) salt = new Uint8Array(hash.outputLen);\n  return hmac(hash, toBytes(salt), toBytes(ikm));\n}\n\nconst HKDF_COUNTER = /* @__PURE__ */ Uint8Array.from([0]);\nconst EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();\n\n/**\n * HKDF-expand from the spec. The most important part. `HKDF-Expand(PRK, info, L) -> OKM`\n * @param hash - hash function that would be used (e.g. sha256)\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in bytes\n */\nexport function expand(hash: CHash, prk: Input, info?: Input, length: number = 32): Uint8Array {\n  ahash(hash);\n  anumber(length);\n  const olen = hash.outputLen;\n  if (length > 255 * olen) throw new Error('Length should be <= 255*HashLen');\n  const blocks = Math.ceil(length / olen);\n  if (info === undefined) info = EMPTY_BUFFER;\n  // first L(ength) octets of T\n  const okm = new Uint8Array(blocks * olen);\n  // Re-use HMAC instance between blocks\n  const HMAC = hmac.create(hash, prk);\n  const HMACTmp = HMAC._cloneInto();\n  const T = new Uint8Array(HMAC.outputLen);\n  for (let counter = 0; counter < blocks; counter++) {\n    HKDF_COUNTER[0] = counter + 1;\n    // T(0) = empty string (zero length)\n    // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n      .update(info)\n      .update(HKDF_COUNTER)\n      .digestInto(T);\n    okm.set(T, olen * counter);\n    HMAC._cloneInto(HMACTmp);\n  }\n  HMAC.destroy();\n  HMACTmp.destroy();\n  clean(T, HKDF_COUNTER);\n  return okm.slice(0, length);\n}\n\n/**\n * HKDF (RFC 5869): derive keys from an initial input.\n * Combines hkdf_extract + hkdf_expand in one step\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in bytes\n * @example\n * import { hkdf } from '@noble/hashes/hkdf';\n * import { sha256 } from '@noble/hashes/sha2';\n * import { randomBytes } from '@noble/hashes/utils';\n * const inputKey = randomBytes(32);\n * const salt = randomBytes(32);\n * const info = 'application-key';\n * const hk1 = hkdf(sha256, inputKey, salt, info, 32);\n */\nexport const hkdf = (\n  hash: CHash,\n  ikm: Input,\n  salt: Input | undefined,\n  info: Input | undefined,\n  length: number\n): Uint8Array => expand(hash, extract(hash, ikm, salt), info, length);\n"],
  "mappings": ";;;;;;;;;;;;AAeM,SAAU,QAAQ,MAAa,KAAY,MAAY;AAC3D,QAAM,IAAI;AAIV,MAAI,SAAS;AAAW,WAAO,IAAI,WAAW,KAAK,SAAS;AAC5D,SAAO,KAAK,MAAM,QAAQ,IAAI,GAAG,QAAQ,GAAG,CAAC;AAC/C;AAEA,IAAM,eAA+B,WAAW,KAAK,CAAC,CAAC,CAAC;AACxD,IAAM,eAA+B,WAAW,GAAE;AAS5C,SAAU,OAAO,MAAa,KAAY,MAAc,SAAiB,IAAE;AAC/E,QAAM,IAAI;AACV,UAAQ,MAAM;AACd,QAAM,OAAO,KAAK;AAClB,MAAI,SAAS,MAAM;AAAM,UAAM,IAAI,MAAM,iCAAiC;AAC1E,QAAM,SAAS,KAAK,KAAK,SAAS,IAAI;AACtC,MAAI,SAAS;AAAW,WAAO;AAE/B,QAAM,MAAM,IAAI,WAAW,SAAS,IAAI;AAExC,QAAM,OAAO,KAAK,OAAO,MAAM,GAAG;AAClC,QAAM,UAAU,KAAK,WAAU;AAC/B,QAAM,IAAI,IAAI,WAAW,KAAK,SAAS;AACvC,WAAS,UAAU,GAAG,UAAU,QAAQ,WAAW;AACjD,iBAAa,CAAC,IAAI,UAAU;AAG5B,YAAQ,OAAO,YAAY,IAAI,eAAe,CAAC,EAC5C,OAAO,IAAI,EACX,OAAO,YAAY,EACnB,WAAW,CAAC;AACf,QAAI,IAAI,GAAG,OAAO,OAAO;AACzB,SAAK,WAAW,OAAO;EACzB;AACA,OAAK,QAAO;AACZ,UAAQ,QAAO;AACf,QAAM,GAAG,YAAY;AACrB,SAAO,IAAI,MAAM,GAAG,MAAM;AAC5B;AAmBO,IAAM,OAAO,CAClB,MACA,KACA,MACA,MACA,WACe,OAAO,MAAM,QAAQ,MAAM,KAAK,IAAI,GAAG,MAAM,MAAM;",
  "names": []
}
