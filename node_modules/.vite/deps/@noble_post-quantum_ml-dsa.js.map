{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/@noble+hashes@1.6.0/node_modules/@noble/hashes/src/_assert.ts", "../../../../../node_modules/.pnpm/@noble+hashes@1.6.0/node_modules/@noble/hashes/src/_u64.ts", "../../../../../node_modules/.pnpm/@noble+hashes@1.6.0/node_modules/@noble/hashes/src/crypto.ts", "../../../../../node_modules/.pnpm/@noble+hashes@1.6.0/node_modules/@noble/hashes/src/utils.ts", "../../../../../node_modules/.pnpm/@noble+hashes@1.6.0/node_modules/@noble/hashes/src/sha3.ts", "../../../../../node_modules/.pnpm/@noble+post-quantum@0.2.1/node_modules/@noble/post-quantum/src/utils.ts", "../../../../../node_modules/.pnpm/@noble+post-quantum@0.2.1/node_modules/@noble/post-quantum/src/_crystals.ts", "../../../../../node_modules/.pnpm/@noble+post-quantum@0.2.1/node_modules/@noble/post-quantum/src/ml-dsa.ts"],
  "sourcesContent": ["function anumber(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n// copied from utils\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction ahash(h: Hash) {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\nfunction aexists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction aoutput(out: any, instance: any) {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport { anumber, anumber as number, abytes, abytes as bytes, ahash, aexists, aoutput };\n\nconst assert = {\n  number: anumber,\n  bytes: abytes,\n  hash: ahash,\n  exists: aexists,\n  output: aoutput,\n};\nexport default assert;\n", "const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\n// BigUint64Array is too slow as per 2024, so we implement it using Uint32Array.\n// TODO: re-check https://issues.chromium.org/issues/42212588\n\nfunction fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number) => l;\nconst rotr32L = (h: number, _l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word: number, shift: number) =>\n  (word << shift) | ((word >>> (32 - shift)) >>> 0);\n\nexport const isLE = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport const byteSwap = (word: number) =>\n  ((word << 24) & 0xff000000) |\n  ((word << 8) & 0xff0000) |\n  ((word >>> 8) & 0xff00) |\n  ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n: number) => n : (n: number) => byteSwap(n);\n\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr: Uint32Array) {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof str);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return crypto.randomBytes(bytesLength);\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "import { abytes, aexists, anumber, aoutput } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport {\n  Hash,\n  u32,\n  Input,\n  toBytes,\n  wrapConstructor,\n  wrapXOFConstructorWithOpts,\n  HashXOF,\n  isLE,\n  byteSwap32,\n} from './utils.js';\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n\n// Various per round constants calculations\nconst SHA3_PI: number[] = [];\nconst SHA3_ROTL: number[] = [];\nconst _SHA3_IOTA: bigint[] = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s: Uint32Array, rounds: number = 24) {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta Œ∏\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho (œÅ) and Pi (œÄ)\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi (œá)\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota (Œπ)\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  B.fill(0);\n}\n\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    public blockLen: number,\n    public suffix: number,\n    public outputLen: number,\n    protected enableXOF = false,\n    protected rounds: number = 24\n  ) {\n    super();\n    // Can be passed from user as dkLen\n    anumber(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    if (0 >= this.blockLen || this.blockLen >= 200)\n      throw new Error('Sha3 supports only keccak-f1600 function');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  protected keccak() {\n    if (!isLE) byteSwap32(this.state32);\n    keccakP(this.state32, this.rounds);\n    if (!isLE) byteSwap32(this.state32);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input) {\n    aexists(this);\n    const { blockLen, state } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish() {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array) {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n", "/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */\nimport { bytes as abytes } from '@noble/hashes/_assert';\nimport { TypedArray, randomBytes as randb, concatBytes } from '@noble/hashes/utils';\n\nexport const ensureBytes = abytes;\nexport const randomBytes = randb;\nexport { concatBytes };\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\nexport type Signer = {\n  signRandBytes: number;\n  keygen: (seed: Uint8Array) => {\n    secretKey: Uint8Array;\n    publicKey: Uint8Array;\n  };\n  sign: (secretKey: Uint8Array, msg: Uint8Array, random?: Uint8Array) => Uint8Array;\n  verify: (publicKey: Uint8Array, msg: Uint8Array, sig: Uint8Array) => boolean;\n};\n\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n\nexport interface BytesCoder<T> extends Coder<T, Uint8Array> {\n  encode: (data: T) => Uint8Array;\n  decode: (bytes: Uint8Array) => T;\n}\n\nexport type BytesCoderLen<T> = BytesCoder<T> & { bytesLen: number };\n\n// nano-packed, because struct encoding is hard.\ntype UnCoder<T> = T extends BytesCoder<infer U> ? U : never;\ntype SplitOut<T extends (number | BytesCoderLen<any>)[]> = {\n  [K in keyof T]: T[K] extends number ? Uint8Array : UnCoder<T[K]>;\n};\nexport function splitCoder<T extends (number | BytesCoderLen<any>)[]>(\n  ...lengths: T\n): BytesCoder<SplitOut<T>> & { bytesLen: number } {\n  const getLength = (c: number | BytesCoderLen<any>) => (typeof c === 'number' ? c : c.bytesLen);\n  const bytesLen: number = lengths.reduce((sum: number, a) => sum + getLength(a), 0);\n  return {\n    bytesLen,\n    encode: (bufs: T) => {\n      const res = new Uint8Array(bytesLen);\n      for (let i = 0, pos = 0; i < lengths.length; i++) {\n        const c = lengths[i];\n        const l = getLength(c);\n        const b: Uint8Array = typeof c === 'number' ? (bufs[i] as any) : c.encode(bufs[i]);\n        ensureBytes(b, l);\n        res.set(b, pos);\n        if (typeof c !== 'number') b.fill(0); // clean\n        pos += l;\n      }\n      return res;\n    },\n    decode: (buf: Uint8Array) => {\n      ensureBytes(buf, bytesLen);\n      const res = [];\n      for (const c of lengths) {\n        const l = getLength(c);\n        const b = buf.subarray(0, l);\n        res.push(typeof c === 'number' ? b : c.decode(b));\n        buf = buf.subarray(l);\n      }\n      return res as SplitOut<T>;\n    },\n  } as any;\n}\n// nano-packed.array (fixed size)\nexport function vecCoder<T>(c: BytesCoderLen<T>, vecLen: number): BytesCoderLen<T[]> {\n  const bytesLen = vecLen * c.bytesLen;\n  return {\n    bytesLen,\n    encode: (u: T[]): Uint8Array => {\n      if (u.length !== vecLen)\n        throw new Error(`vecCoder.encode: wrong length=${u.length}. Expected: ${vecLen}`);\n      const res = new Uint8Array(bytesLen);\n      for (let i = 0, pos = 0; i < u.length; i++) {\n        const b = c.encode(u[i]);\n        res.set(b, pos);\n        b.fill(0); // clean\n        pos += b.length;\n      }\n      return res;\n    },\n    decode: (a: Uint8Array): T[] => {\n      ensureBytes(a, bytesLen);\n      const r: T[] = [];\n      for (let i = 0; i < a.length; i += c.bytesLen)\n        r.push(c.decode(a.subarray(i, i + c.bytesLen)));\n      return r;\n    },\n  };\n}\n\n// cleanBytes(new Uint8Array(), [new Uint16Array(), new Uint32Array()])\nexport function cleanBytes(...list: (TypedArray | TypedArray[])[]) {\n  for (const t of list) {\n    if (Array.isArray(t)) for (const b of t) b.fill(0);\n    else t.fill(0);\n  }\n}\n\nexport function getMask(bits: number) {\n  return (1 << bits) - 1; // 4 -> 0b1111\n}\n", "/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */\nimport { shake128, shake256 } from '@noble/hashes/sha3';\nimport type { TypedArray } from '@noble/hashes/utils';\nimport { BytesCoderLen, Coder, getMask } from './utils.js';\n\nexport type XOF = (\n  seed: Uint8Array,\n  blockLen?: number\n) => {\n  stats: () => { calls: number; xofs: number };\n  get: (x: number, y: number) => () => Uint8Array; // return block aligned to blockLen and 3\n  clean: () => void;\n};\n\nexport type CrystalOpts<T extends TypedArray> = {\n  newPoly: TypedCons<T>;\n  N: number; // poly size, 256\n  Q: number; // modulo\n  F: number; // 256**‚àí1 mod q for dilithium, 128**‚àí1 mod q for kyber\n  ROOT_OF_UNITY: number;\n  brvBits: number; // bits for bitReversal\n  isKyber: boolean;\n};\n\nexport type TypedCons<T extends TypedArray> = (n: number) => T;\n\n// TODO: benchmark\nfunction bitReversal(n: number, bits: number = 8) {\n  const padded = n.toString(2).padStart(8, '0');\n  const sliced = padded.slice(-bits).padStart(7, '0');\n  const revrsd = sliced.split('').reverse().join('');\n  return Number.parseInt(revrsd, 2);\n}\n\nexport const genCrystals = <T extends TypedArray>(opts: CrystalOpts<T>) => {\n  // isKyber: true means Kyber, false means Dilithium\n  const { newPoly, N, Q, F, ROOT_OF_UNITY, brvBits, isKyber } = opts;\n  const mod = (a: number, modulo = Q): number => {\n    const result = a % modulo | 0;\n    return (result >= 0 ? result | 0 : (modulo + result) | 0) | 0;\n  };\n  // -(Q-1)/2 < a <= (Q-1)/2\n  const smod = (a: number, modulo = Q): number => {\n    const r = mod(a, modulo) | 0;\n    return (r > modulo >> 1 ? (r - modulo) | 0 : r) | 0;\n  };\n  // Generate zettas\n  function getZettas() {\n    const out = newPoly(N);\n    for (let i = 0; i < N; i++) {\n      const b = bitReversal(i, brvBits);\n      const p = BigInt(ROOT_OF_UNITY) ** BigInt(b) % BigInt(Q);\n      out[i] = Number(p) | 0;\n    }\n    return out;\n  }\n  const nttZetas = getZettas();\n\n  // Number-Theoretic Transform\n  // Explained: https://electricdusk.com/ntt.html\n\n  // Kyber has slightly different params, since there is no 512th primitive root of unity mod q,\n  // only 256th primitive root of unity mod. Which also complicates MultiplyNTT.\n  // TODO: there should be less ugly way to define this.\n  const LEN1 = isKyber ? 128 : N;\n  const LEN2 = isKyber ? 1 : 0;\n  const NTT = {\n    encode: (r: T) => {\n      for (let k = 1, len = 128; len > LEN2; len >>= 1) {\n        for (let start = 0; start < N; start += 2 * len) {\n          const zeta = nttZetas[k++];\n          for (let j = start; j < start + len; j++) {\n            const t = mod(zeta * r[j + len]);\n            r[j + len] = mod(r[j] - t) | 0;\n            r[j] = mod(r[j] + t) | 0;\n          }\n        }\n      }\n      return r;\n    },\n    decode: (r: T) => {\n      for (let k = LEN1 - 1, len = 1 + LEN2; len < LEN1 + LEN2; len <<= 1) {\n        for (let start = 0; start < N; start += 2 * len) {\n          const zeta = nttZetas[k--];\n          for (let j = start; j < start + len; j++) {\n            const t = r[j];\n            r[j] = mod(t + r[j + len]);\n            r[j + len] = mod(zeta * (r[j + len] - t));\n          }\n        }\n      }\n      for (let i = 0; i < r.length; i++) r[i] = mod(F * r[i]);\n      return r;\n    },\n  };\n  // Encode polynominal as bits\n  const bitsCoder = (d: number, c: Coder<number, number>): BytesCoderLen<T> => {\n    const mask = getMask(d);\n    const bytesLen = d * (N / 8);\n    return {\n      bytesLen,\n      encode: (poly: T): Uint8Array => {\n        const r = new Uint8Array(bytesLen);\n        for (let i = 0, buf = 0, bufLen = 0, pos = 0; i < poly.length; i++) {\n          buf |= (c.encode(poly[i]) & mask) << bufLen;\n          bufLen += d;\n          for (; bufLen >= 8; bufLen -= 8, buf >>= 8) r[pos++] = buf & getMask(bufLen);\n        }\n        return r;\n      },\n      decode: (bytes: Uint8Array): T => {\n        const r = newPoly(N);\n        for (let i = 0, buf = 0, bufLen = 0, pos = 0; i < bytes.length; i++) {\n          buf |= bytes[i] << bufLen;\n          bufLen += 8;\n          for (; bufLen >= d; bufLen -= d, buf >>= d) r[pos++] = c.decode(buf & mask);\n        }\n        return r;\n      },\n    };\n  };\n\n  return { mod, smod, nttZetas, NTT, bitsCoder };\n};\n\nconst createXofShake =\n  (shake: typeof shake128): XOF =>\n  (seed: Uint8Array, blockLen?: number) => {\n    if (!blockLen) blockLen = shake.blockLen;\n    // Optimizations that won't mater:\n    // - cached seed update (two .update(), on start and on the end)\n    // - another cache which cloned into working copy\n\n    // Faster than multiple updates, since seed less than blockLen\n    const _seed = new Uint8Array(seed.length + 2);\n    _seed.set(seed);\n    const seedLen = seed.length;\n    const buf = new Uint8Array(blockLen); // == shake128.blockLen\n    let h = shake.create({});\n    let calls = 0;\n    let xofs = 0;\n    return {\n      stats: () => ({ calls, xofs }),\n      get: (x: number, y: number) => {\n        _seed[seedLen + 0] = x;\n        _seed[seedLen + 1] = y;\n        h.destroy();\n        h = shake.create({}).update(_seed);\n        calls++;\n        return () => {\n          xofs++;\n          return h.xofInto(buf);\n        };\n      },\n      clean: () => {\n        h.destroy();\n        buf.fill(0);\n        _seed.fill(0);\n      },\n    };\n  };\n\nexport const XOF128 = /* @__PURE__ */ createXofShake(shake128);\nexport const XOF256 = /* @__PURE__ */ createXofShake(shake256);\n", "/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */\nimport { shake256 } from '@noble/hashes/sha3';\nimport { genCrystals, XOF, XOF128, XOF256 } from './_crystals.js';\nimport {\n  BytesCoderLen,\n  Signer,\n  cleanBytes,\n  ensureBytes,\n  equalBytes,\n  randomBytes,\n  splitCoder,\n  vecCoder,\n  concatBytes,\n} from './utils.js';\n\n/*\nLattice-based digital signature algorithm. See\n[official site](https://www.pq-crystals.org/dilithium/index.shtml),\n[repo](https://github.com/pq-crystals/dilithium).\nDilithium has similar internals to Kyber, but their keys and params are different.\n\n*/\n\n// Constants\nconst N = 256;\n// 2**23 ‚àí 2**13 + 1, 23 bits: multiply will be 46. We have enough precision in JS to avoid bigints\nconst Q = 8380417;\nconst ROOT_OF_UNITY = 1753;\n// f = 256**‚àí1 mod q, pow(256, -1, q) = 8347681 (python3)\nconst F = 8347681;\nconst D = 13;\n// Dilithium is kinda parametrized over GAMMA2, but everything will break with any other value.\nconst GAMMA2_1 = Math.floor((Q - 1) / 88) | 0;\nconst GAMMA2_2 = Math.floor((Q - 1) / 32) | 0;\n\ntype XofGet = ReturnType<ReturnType<XOF>['get']>;\n\ntype Param = {\n  K: number;\n  L: number;\n  D: number;\n  GAMMA1: number;\n  GAMMA2: number;\n  TAU: number;\n  ETA: number;\n  OMEGA: number;\n};\n// prettier-ignore\nexport const PARAMS: Record<string, Param> = {\n  2: { K: 4, L: 4, D, GAMMA1: 2 ** 17, GAMMA2: GAMMA2_1, TAU: 39, ETA: 2, OMEGA: 80 },\n  3: { K: 6, L: 5, D, GAMMA1: 2 ** 19, GAMMA2: GAMMA2_2, TAU: 49, ETA: 4, OMEGA: 55 },\n  5: { K: 8, L: 7, D, GAMMA1: 2 ** 19, GAMMA2: GAMMA2_2, TAU: 60, ETA: 2, OMEGA: 75 },\n} as const;\n\n// NOTE: there is a lot cases where negative numbers used (with smod instead of mod).\ntype Poly = Int32Array;\nconst newPoly = (n: number) => new Int32Array(n);\n\nconst { mod, smod, NTT, bitsCoder } = genCrystals({\n  N,\n  Q,\n  F,\n  ROOT_OF_UNITY,\n  newPoly,\n  isKyber: false,\n  brvBits: 8,\n});\n\nconst id = <T>(n: T): T => n;\ntype IdNum = (n: number) => number;\n\nconst polyCoder = (d: number, compress: IdNum = id, verify: IdNum = id) =>\n  bitsCoder(d, {\n    encode: (i: number) => compress(verify(i)),\n    decode: (i: number) => verify(compress(i)),\n  });\n\nconst polyAdd = (a: Poly, b: Poly) => {\n  for (let i = 0; i < a.length; i++) a[i] = mod(a[i] + b[i]);\n  return a;\n};\nconst polySub = (a: Poly, b: Poly): Poly => {\n  for (let i = 0; i < a.length; i++) a[i] = mod(a[i] - b[i]);\n  return a;\n};\n\nconst polyShiftl = (p: Poly): Poly => {\n  for (let i = 0; i < N; i++) p[i] <<= D;\n  return p;\n};\n\nconst polyChknorm = (p: Poly, B: number): boolean => {\n  // Not very sure about this, but FIPS204 doesn't provide any function for that :(\n  for (let i = 0; i < N; i++) if (Math.abs(smod(p[i])) >= B) return true;\n  return false;\n};\n\nconst MultiplyNTTs = (a: Poly, b: Poly): Poly => {\n  // NOTE: we don't use montgomery reduction in code, since it requires 64 bit ints,\n  // which is not available in JS. mod(a[i] * b[i]) is ok, since Q is 23 bit,\n  // which means a[i] * b[i] is 46 bit, which is safe to use in JS. (number is 53 bits).\n  // Barrett reduction is slower than mod :(\n  const c = newPoly(N);\n  for (let i = 0; i < a.length; i++) c[i] = mod(a[i] * b[i]);\n  return c;\n};\n\n// Return poly in NTT representation\nfunction RejNTTPoly(xof: XofGet) {\n  // Samples a polynomial ‚àà Tq.\n  const r = newPoly(N);\n  // NOTE: we can represent 3xu24 as 4xu32, but it doesn't improve perf :(\n  for (let j = 0; j < N; ) {\n    const b = xof();\n    if (b.length % 3) throw new Error('RejNTTPoly: unaligned block');\n    for (let i = 0; j < N && i <= b.length - 3; i += 3) {\n      const t = (b[i + 0] | (b[i + 1] << 8) | (b[i + 2] << 16)) & 0x7fffff; // 3 bytes\n      if (t < Q) r[j++] = t;\n    }\n  }\n  return r;\n}\n\nconst EMPTY = new Uint8Array(0);\n\ntype DilithiumOpts = {\n  K: number;\n  L: number;\n  GAMMA1: number;\n  GAMMA2: number;\n  TAU: number;\n  ETA: number;\n  OMEGA: number;\n  C_TILDE_BYTES: number;\n  CRH_BYTES: number;\n  TR_BYTES: number;\n  XOF128: XOF;\n  XOF256: XOF;\n};\n\nfunction getDilithium(opts: DilithiumOpts) {\n  const { K, L, GAMMA1, GAMMA2, TAU, ETA, OMEGA } = opts;\n  const { CRH_BYTES, TR_BYTES, C_TILDE_BYTES, XOF128, XOF256 } = opts;\n\n  if (![2, 4].includes(ETA)) throw new Error('Wrong ETA');\n  if (![1 << 17, 1 << 19].includes(GAMMA1)) throw new Error('Wrong GAMMA1');\n  if (![GAMMA2_1, GAMMA2_2].includes(GAMMA2)) throw new Error('Wrong GAMMA2');\n  const BETA = TAU * ETA;\n\n  const decompose = (r: number) => {\n    // Decomposes r into (r1, r0) such that r ‚â° r1(2Œ≥2) + r0 mod q.\n    const rPlus = mod(r);\n    const r0 = smod(rPlus, 2 * GAMMA2) | 0;\n    if (rPlus - r0 === Q - 1) return { r1: 0 | 0, r0: (r0 - 1) | 0 };\n    const r1 = Math.floor((rPlus - r0) / (2 * GAMMA2)) | 0;\n    return { r1, r0 }; // r1 = HighBits, r0 = LowBits\n  };\n\n  const HighBits = (r: number) => decompose(r).r1;\n  const LowBits = (r: number) => decompose(r).r0;\n  const MakeHint = (z: number, r: number) => {\n    // Compute hint bit indicating whether adding z to r alters the high bits of r.\n\n    // From dilithium code\n    const res0 = z <= GAMMA2 || z > Q - GAMMA2 || (z === Q - GAMMA2 && r === 0) ? 0 : 1;\n    // from FIPS204:\n    // // const r1 = HighBits(r);\n    // // const v1 = HighBits(r + z);\n    // // const res1 = +(r1 !== v1);\n    // But they return different results! However, decompose is same.\n    // So, either there is a bug in Dilithium ref implementation or in FIPS204.\n    // For now, lets use dilithium one, so test vectors can be passed.\n    // See\n    // https://github.com/GiacomoPope/dilithium-py?tab=readme-ov-file#optimising-decomposition-and-making-hints\n    return res0;\n  };\n\n  const UseHint = (h: number, r: number) => {\n    // Returns the high bits of r adjusted according to hint h\n    const m = Math.floor((Q - 1) / (2 * GAMMA2));\n    const { r1, r0 } = decompose(r);\n    // 3: if h = 1 and r0 > 0 return (r1 + 1) mod m\n    // 4: if h = 1 and r0 ‚â§ 0 return (r1 ‚àí 1) mod m\n    if (h === 1) return r0 > 0 ? mod(r1 + 1, m) | 0 : mod(r1 - 1, m) | 0;\n    return r1 | 0;\n  };\n  const Power2Round = (r: number) => {\n    // Decomposes r into (r1, r0) such that r ‚â° r1*(2**d) + r0 mod q.\n    const rPlus = mod(r);\n    const r0 = smod(rPlus, 2 ** D) | 0;\n    return { r1: Math.floor((rPlus - r0) / 2 ** D) | 0, r0 };\n  };\n\n  const hintCoder: BytesCoderLen<Poly[] | false> = {\n    bytesLen: OMEGA + K,\n    encode: (h: Poly[] | false) => {\n      if (h === false) throw new Error('hint.encode: hint is false'); // should never happen\n      const res = new Uint8Array(OMEGA + K);\n      for (let i = 0, k = 0; i < K; i++) {\n        for (let j = 0; j < N; j++) if (h[i][j] !== 0) res[k++] = j;\n        res[OMEGA + i] = k;\n      }\n      return res;\n    },\n    decode: (buf: Uint8Array) => {\n      const h = [];\n      let k = 0;\n      for (let i = 0; i < K; i++) {\n        const hi = newPoly(N);\n        if (buf[OMEGA + i] < k || buf[OMEGA + i] > OMEGA) return false;\n        for (let j = k; j < buf[OMEGA + i]; j++) {\n          if (j > k && buf[j] <= buf[j - 1]) return false;\n          hi[buf[j]] = 1;\n        }\n        k = buf[OMEGA + i];\n        h.push(hi);\n      }\n      for (let j = k; j < OMEGA; j++) if (buf[j] !== 0) return false;\n      return h;\n    },\n  };\n\n  const ETACoder = polyCoder(\n    ETA === 2 ? 3 : 4,\n    (i: number) => ETA - i,\n    (i: number) => {\n      if (!(-ETA <= i && i <= ETA))\n        throw new Error(`malformed key s1/s3 ${i} outside of ETA range [${-ETA}, ${ETA}]`);\n      return i;\n    }\n  );\n  const T0Coder = polyCoder(13, (i: number) => (1 << (D - 1)) - i);\n  const T1Coder = polyCoder(10);\n  // Requires smod. Need to fix!\n  const ZCoder = polyCoder(GAMMA1 === 1 << 17 ? 18 : 20, (i: number) => smod(GAMMA1 - i));\n  const W1Coder = polyCoder(GAMMA2 === GAMMA2_1 ? 6 : 4);\n  const W1Vec = vecCoder(W1Coder, K);\n  // Main structures\n  const publicCoder = splitCoder(32, vecCoder(T1Coder, K));\n  const secretCoder = splitCoder(\n    32,\n    32,\n    TR_BYTES,\n    vecCoder(ETACoder, L),\n    vecCoder(ETACoder, K),\n    vecCoder(T0Coder, K)\n  );\n  const sigCoder = splitCoder(C_TILDE_BYTES, vecCoder(ZCoder, L), hintCoder);\n  const CoefFromHalfByte =\n    ETA === 2\n      ? (n: number) => (n < 15 ? 2 - (n % 5) : false)\n      : (n: number) => (n < 9 ? 4 - n : false);\n\n  // Return poly in NTT representation\n  function RejBoundedPoly(xof: XofGet) {\n    // Samples an element a ‚àà Rq with coeffcients in [‚àíŒ∑, Œ∑] computed via rejection sampling from œÅ.\n    const r: Poly = newPoly(N);\n    for (let j = 0; j < N; ) {\n      const b = xof();\n      for (let i = 0; j < N && i < b.length; i += 1) {\n        // half byte. Should be superfast with vector instructions. But very slow with js :(\n        const d1 = CoefFromHalfByte(b[i] & 0x0f);\n        const d2 = CoefFromHalfByte((b[i] >> 4) & 0x0f);\n        if (d1 !== false) r[j++] = d1;\n        if (j < N && d2 !== false) r[j++] = d2;\n      }\n    }\n    return r;\n  }\n\n  const SampleInBall = (seed: Uint8Array) => {\n    // Samples a polynomial c ‚àà Rq with coeffcients from {‚àí1, 0, 1} and Hamming weight œÑ\n    const pre = newPoly(N);\n    const s = shake256.create({}).update(seed);\n    const buf = new Uint8Array(shake256.blockLen);\n    s.xofInto(buf);\n    const masks = buf.slice(0, 8);\n    for (let i = N - TAU, pos = 8, maskPos = 0, maskBit = 0; i < N; i++) {\n      let b = i + 1;\n      for (; b > i; ) {\n        b = buf[pos++];\n        if (pos < shake256.blockLen) continue;\n        s.xofInto(buf);\n        pos = 0;\n      }\n      pre[i] = pre[b];\n      pre[b] = 1 - (((masks[maskPos] >> maskBit++) & 1) << 1);\n      if (maskBit >= 8) {\n        maskPos++;\n        maskBit = 0;\n      }\n    }\n    return pre;\n  };\n\n  const polyPowerRound = (p: Poly) => {\n    const res0 = newPoly(N);\n    const res1 = newPoly(N);\n    for (let i = 0; i < p.length; i++) {\n      const { r0, r1 } = Power2Round(p[i]);\n      res0[i] = r0;\n      res1[i] = r1;\n    }\n    return { r0: res0, r1: res1 };\n  };\n  const polyUseHint = (u: Poly, h: Poly): Poly => {\n    for (let i = 0; i < N; i++) u[i] = UseHint(h[i], u[i]);\n    return u;\n  };\n  const polyMakeHint = (a: Poly, b: Poly) => {\n    const v = newPoly(N);\n    let cnt = 0;\n    for (let i = 0; i < N; i++) {\n      const h = MakeHint(a[i], b[i]);\n      v[i] = h;\n      cnt += h;\n    }\n    return { v, cnt };\n  };\n\n  const signRandBytes = 32;\n  const seedCoder = splitCoder(32, 64, 32);\n  // API & argument positions are exactly as in FIPS204.\n  const internal: Signer = {\n    signRandBytes,\n    keygen: (seed = randomBytes(32)) => {\n      // H(ùúâ||IntegerToBytes(ùëò, 1)||IntegerToBytes(‚Ñì, 1), 128) 2: ‚ñ∑ expand seed\n      const seedDst = new Uint8Array(32 + 2);\n      seedDst.set(seed);\n      seedDst[32] = K;\n      seedDst[33] = L;\n      const [rho, rhoPrime, K_] = seedCoder.decode(\n        shake256(seedDst, { dkLen: seedCoder.bytesLen })\n      );\n      const xofPrime = XOF256(rhoPrime);\n      const s1 = [];\n      for (let i = 0; i < L; i++) s1.push(RejBoundedPoly(xofPrime.get(i & 0xff, (i >> 8) & 0xff)));\n      const s2 = [];\n      for (let i = L; i < L + K; i++)\n        s2.push(RejBoundedPoly(xofPrime.get(i & 0xff, (i >> 8) & 0xff)));\n      const s1Hat = s1.map((i) => NTT.encode(i.slice()));\n      const t0 = [];\n      const t1 = [];\n      const xof = XOF128(rho);\n      const t = newPoly(N);\n      for (let i = 0; i < K; i++) {\n        // t ‚Üê NTT‚àí1(A*NTT(s1)) + s2\n        t.fill(0); // don't-reallocate\n        for (let j = 0; j < L; j++) {\n          const aij = RejNTTPoly(xof.get(j, i)); // super slow!\n          polyAdd(t, MultiplyNTTs(aij, s1Hat[j]));\n        }\n        NTT.decode(t);\n        const { r0, r1 } = polyPowerRound(polyAdd(t, s2[i])); // (t1, t0) ‚Üê Power2Round(t, d)\n        t0.push(r0);\n        t1.push(r1);\n      }\n      const publicKey = publicCoder.encode([rho, t1]); // pk ‚Üê pkEncode(œÅ, t1)\n      const tr = shake256(publicKey, { dkLen: TR_BYTES }); // tr ‚Üê H(BytesToBits(pk), 512)\n      const secretKey = secretCoder.encode([rho, K_, tr, s1, s2, t0]); // sk ‚Üê skEncode(œÅ, K,tr, s1, s2, t0)\n      xof.clean();\n      xofPrime.clean();\n      // STATS\n      // Kyber512:  { calls: 4, xofs: 12 }, Kyber768: { calls: 9, xofs: 27 }, Kyber1024: { calls: 16, xofs: 48 }\n      // DSA44:    { calls: 24, xofs: 24 }, DSA65:    { calls: 41, xofs: 41 }, DSA87:    { calls: 71, xofs: 71 }\n      cleanBytes(rho, rhoPrime, K_, s1, s2, s1Hat, t, t0, t1, tr, seedDst);\n      return { publicKey, secretKey };\n    },\n    // NOTE: random is optional.\n    sign: (secretKey: Uint8Array, msg: Uint8Array, random?: Uint8Array) => {\n      // This part can be pre-cached per secretKey, but there is only minor performance improvement,\n      // since we re-use a lot of variables to computation.\n      const [rho, _K, tr, s1, s2, t0] = secretCoder.decode(secretKey); // (œÅ, K,tr, s1, s2, t0) ‚Üê skDecode(sk)\n      // Cache matrix to avoid re-compute later\n      const A: Poly[][] = []; // A ‚Üê ExpandA(œÅ)\n      const xof = XOF128(rho);\n      for (let i = 0; i < K; i++) {\n        const pv = [];\n        for (let j = 0; j < L; j++) pv.push(RejNTTPoly(xof.get(j, i)));\n        A.push(pv);\n      }\n      xof.clean();\n      for (let i = 0; i < L; i++) NTT.encode(s1[i]); // sÀÜ1 ‚Üê NTT(s1)\n      for (let i = 0; i < K; i++) {\n        NTT.encode(s2[i]); // sÀÜ2 ‚Üê NTT(s2)\n        NTT.encode(t0[i]); // tÀÜ0 ‚Üê NTT(t0)\n      }\n      // This part is per msg\n      const mu = shake256.create({ dkLen: CRH_BYTES }).update(tr).update(msg).digest(); // 6: ¬µ ‚Üê H(tr||M, 512) ‚ñ∑ Compute message representative ¬µ\n\n      // Compute private random seed\n      const rnd = random ? random : new Uint8Array(32);\n      ensureBytes(rnd);\n      const rhoprime = shake256\n        .create({ dkLen: CRH_BYTES })\n        .update(_K)\n        .update(rnd)\n        .update(mu)\n        .digest(); // œÅ‚Ä≤‚Üê H(K||rnd||¬µ, 512)\n\n      ensureBytes(rhoprime, CRH_BYTES);\n      const x256 = XOF256(rhoprime, ZCoder.bytesLen);\n      //  Rejection sampling loop\n      main_loop: for (let kappa = 0; ; ) {\n        const y = [];\n        // y ‚Üê ExpandMask(œÅ , Œ∫)\n        for (let i = 0; i < L; i++, kappa++)\n          y.push(ZCoder.decode(x256.get(kappa & 0xff, kappa >> 8)()));\n        const z = y.map((i) => NTT.encode(i.slice()));\n        const w = [];\n        for (let i = 0; i < K; i++) {\n          // w ‚Üê NTT‚àí1(A ‚ó¶ NTT(y))\n          const wi = newPoly(N);\n          for (let j = 0; j < L; j++) polyAdd(wi, MultiplyNTTs(A[i][j], z[j]));\n          NTT.decode(wi);\n          w.push(wi);\n        }\n        const w1 = w.map((j) => j.map(HighBits)); // w1 ‚Üê HighBits(w)\n        // Commitment hash: cÀú ‚àà{0, 1 2Œª } ‚Üê H(¬µ||w1Encode(w1), 2Œª)\n        const cTilde = shake256\n          .create({ dkLen: C_TILDE_BYTES })\n          .update(mu)\n          .update(W1Vec.encode(w1))\n          .digest();\n        // Verifer‚Äôs challenge\n        const cHat = NTT.encode(SampleInBall(cTilde)); // c ‚Üê SampleInBall(cÀú1); cÀÜ ‚Üê NTT(c)\n        // ‚ü®‚ü®cs1‚ü©‚ü© ‚Üê NTT‚àí1(cÀÜ‚ó¶ sÀÜ1)\n        const cs1 = s1.map((i) => MultiplyNTTs(i, cHat));\n        for (let i = 0; i < L; i++) {\n          polyAdd(NTT.decode(cs1[i]), y[i]); // z ‚Üê y + ‚ü®‚ü®cs1‚ü©‚ü©\n          if (polyChknorm(cs1[i], GAMMA1 - BETA)) continue main_loop; // ||z||‚àû ‚â• Œ≥1 ‚àí Œ≤\n        }\n        // cs1 is now z (‚ñ∑ Signer‚Äôs response)\n        let cnt = 0;\n        const h = [];\n        for (let i = 0; i < K; i++) {\n          const cs2 = NTT.decode(MultiplyNTTs(s2[i], cHat)); // ‚ü®‚ü®cs2‚ü©‚ü© ‚Üê NTT‚àí1(cÀÜ‚ó¶ sÀÜ2)\n          const r0 = polySub(w[i], cs2).map(LowBits); // r0 ‚Üê LowBits(w ‚àí ‚ü®‚ü®cs2‚ü©‚ü©)\n          if (polyChknorm(r0, GAMMA2 - BETA)) continue main_loop; // ||r0||‚àû ‚â• Œ≥2 ‚àí Œ≤\n          const ct0 = NTT.decode(MultiplyNTTs(t0[i], cHat)); // ‚ü®‚ü®ct0‚ü©‚ü© ‚Üê NTT‚àí1(cÀÜ‚ó¶ tÀÜ0)\n          if (polyChknorm(ct0, GAMMA2)) continue main_loop;\n          polyAdd(r0, ct0);\n          // ‚ñ∑ Signer‚Äôs hint\n          const hint = polyMakeHint(r0, w1[i]); // h ‚Üê MakeHint(‚àí‚ü®‚ü®ct0‚ü©‚ü©, w‚àí ‚ü®‚ü®cs2‚ü©‚ü© + ‚ü®‚ü®ct0‚ü©‚ü©)\n          h.push(hint.v);\n          cnt += hint.cnt;\n        }\n        if (cnt > OMEGA) continue; // the number of 1‚Äôs in h is greater than œâ\n        x256.clean();\n        const res = sigCoder.encode([cTilde, cs1, h]); // œÉ ‚Üê sigEncode(cÀú, z mod¬±q, h)\n        // rho, _K, tr is subarray of secretKey, cannot clean.\n        cleanBytes(cTilde, cs1, h, cHat, w1, w, z, y, rhoprime, mu, s1, s2, t0, ...A);\n        return res;\n      }\n      // @ts-ignore\n      throw new Error('Unreachable code path reached, report this error');\n    },\n    verify: (publicKey: Uint8Array, msg: Uint8Array, sig: Uint8Array) => {\n      // ML-DSA.Verify(pk, M, œÉ): Verifes a signature œÉ for a message M.\n      const [rho, t1] = publicCoder.decode(publicKey); // (œÅ, t1) ‚Üê pkDecode(pk)\n      const tr = shake256(publicKey, { dkLen: TR_BYTES }); // 6: tr ‚Üê H(BytesToBits(pk), 512)\n\n      if (sig.length !== sigCoder.bytesLen) return false; // return false instead of exception\n      const [cTilde, z, h] = sigCoder.decode(sig); // (cÀú, z, h) ‚Üê sigDecode(œÉ), ‚ñ∑ Signer‚Äôs commitment hash c Àú, response z and hint\n      if (h === false) return false; // if h = ‚ä• then return false\n      for (let i = 0; i < L; i++) if (polyChknorm(z[i], GAMMA1 - BETA)) return false;\n      const mu = shake256.create({ dkLen: CRH_BYTES }).update(tr).update(msg).digest(); // 7: ¬µ ‚Üê H(tr||M, 512)\n      // Compute verifer‚Äôs challenge from cÀú\n      const c = NTT.encode(SampleInBall(cTilde)); // c ‚Üê SampleInBall(cÀú1)\n      const zNtt = z.map((i) => i.slice()); // zNtt = NTT(z)\n      for (let i = 0; i < L; i++) NTT.encode(zNtt[i]);\n      const wTick1 = [];\n      const xof = XOF128(rho);\n      for (let i = 0; i < K; i++) {\n        const ct12d = MultiplyNTTs(NTT.encode(polyShiftl(t1[i])), c); //c * t1 * (2**d)\n        const Az = newPoly(N); // // A * z\n        for (let j = 0; j < L; j++) {\n          const aij = RejNTTPoly(xof.get(j, i)); // A[i][j] inplace\n          polyAdd(Az, MultiplyNTTs(aij, zNtt[j]));\n        }\n        // wApprox = A*z - c*t1 * (2**d)\n        const wApprox = NTT.decode(polySub(Az, ct12d));\n        // Reconstruction of signer‚Äôs commitment\n        wTick1.push(polyUseHint(wApprox, h[i])); // w ‚Ä≤ ‚Üê UseHint(h, w'approx )\n      }\n      xof.clean();\n      // cÀú‚Ä≤‚Üê H (¬µ||w1Encode(w‚Ä≤1), 2Œª),  Hash it; this should match cÀú\n      const c2 = shake256\n        .create({ dkLen: C_TILDE_BYTES })\n        .update(mu)\n        .update(W1Vec.encode(wTick1))\n        .digest();\n      // Additional checks in FIPS-204:\n      // [[ ||z||‚àû < Œ≥1 ‚àí Œ≤ ]] and [[c Àú = cÀú‚Ä≤]] and [[number of 1‚Äôs in h is ‚â§ œâ]]\n      for (const t of h) {\n        const sum = t.reduce((acc, i) => acc + i, 0);\n        if (!(sum <= OMEGA)) return false;\n      }\n      for (const t of z) if (polyChknorm(t, GAMMA1 - BETA)) return false;\n      return equalBytes(cTilde, c2);\n    },\n  };\n  const getMessage = (msg: Uint8Array, ctx = EMPTY) => {\n    ensureBytes(msg);\n    ensureBytes(ctx);\n    if (ctx.length > 255) throw new Error('context should be less than 255 bytes');\n    return concatBytes(new Uint8Array([0, ctx.length]), ctx, msg);\n  };\n  // TODO: no hash-dsa vectors for now, so we don't implement it yet\n  return {\n    internal,\n    keygen: internal.keygen,\n    signRandBytes: internal.signRandBytes,\n    sign: (secretKey: Uint8Array, msg: Uint8Array, ctx = EMPTY, random?: Uint8Array) => {\n      const M = getMessage(msg, ctx);\n      const res = internal.sign(secretKey, M, random);\n      M.fill(0);\n      return res;\n    },\n    verify: (publicKey: Uint8Array, msg: Uint8Array, sig: Uint8Array, ctx = EMPTY) => {\n      return internal.verify(publicKey, getMessage(msg, ctx), sig);\n    },\n  };\n}\n\n// ML-DSA\nexport const ml_dsa44 = /* @__PURE__ */ getDilithium({\n  ...PARAMS[2],\n  CRH_BYTES: 64,\n  TR_BYTES: 64,\n  C_TILDE_BYTES: 32,\n  XOF128,\n  XOF256,\n});\n\nexport const ml_dsa65 = /* @__PURE__ */ getDilithium({\n  ...PARAMS[3],\n  CRH_BYTES: 64,\n  TR_BYTES: 64,\n  C_TILDE_BYTES: 48,\n  XOF128,\n  XOF256,\n});\n\nexport const ml_dsa87 = /* @__PURE__ */ getDilithium({\n  ...PARAMS[5],\n  CRH_BYTES: 64,\n  TR_BYTES: 64,\n  C_TILDE_BYTES: 64,\n  XOF128,\n  XOF256,\n});\n"],
  "mappings": "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",
  "names": ["randomBytes", "newPoly", "N", "Q", "F", "ROOT_OF_UNITY", "mod", "smod", "NTT", "bitsCoder", "XOF128", "XOF256", "randomBytes"]
}
